// SPDX-License-Identifier: MIT

namespace did_sidekicks {
    /// The helper parses the supplied DID doc as string and returns a cryptographic public key (`Jwk`) referenced by the supplied `key_id`, if any.
    ///
    /// Parsing failure is denoted by returning `DidSidekicksError::DeserializationFailed`.
    ///
    /// The key lookup is always done across all verification methods (`verificationMethod`) and
    /// verification relationships
    /// (`authentication`, `assertionMethod`, `keyAgreement`, `capabilityInvocation`, `capabilityInvocation`).
    ///
    /// If no such key exists, `DidSidekicksError::KeyNotFound` is returned.
    [Throws=DidSidekicksError]
    Jwk get_key_from_did_doc(string did_doc, string key_id);
};


/// The error accompanying this crate.
[Error]
enum DidSidekicksError {
    /// Failed to serialize DID document (to JSON).
    "SerializationFailed",
    /// The supplied DID document is invalid or contains an argument which isn't part of the did specification/recommendation.
    "DeserializationFailed",
    /// Invalid DID document.
    "InvalidDidDocument",
    /// Invalid DID log integration proof.
    "InvalidDataIntegrityProof",
    /// Invalid DID method parameter.
    "InvalidDidMethodParameter",
    /// Failed to calculate SHA2-256 hash of canonical JSON UTF-8 string.
    "JscHashingFailed",
    /// No such JWK in the DID document.
    "KeyNotFound",
    /// Failed to save key.
    "KeySerializationFailed",
    /// Failure of a signature to satisfy the verification equation.
    "KeySignatureError",
    /// Failed to load key.
    "KeyDeserializationFailed",
    /// Failed to convert key from multibase format
    "MultibaseKeyConversionFailed",
    /// Non-existing key referenced in the DID document.
    "NonExistingKeyReferenced",
    /// A request to generate a proof failed, as specified by https://www.w3.org/TR/vc-data-integrity/#processing-errors
    "VCDataIntegrityProofGenerationError",
    /// An error was encountered during proof verification, as specified by https://www.w3.org/TR/vc-data-integrity/#processing-errors
    "VCDataIntegrityProofVerificationError",
    /// An error was encountered during the transformation process, as specified by https://www.w3.org/TR/vc-data-integrity/#processing-errors
    "VCDataIntegrityProofTransformationError",
};

/// A generic DID method parameter as seen from the perspective of a JSON deserializer.
///
/// The value returned by `DidMethodParameter`'s getter `get_json_text` is guaranteed to be deserializable back into a JSON object.
interface DidMethodParameter {
    string get_name();
    string get_json_text();
    boolean is_bool();
    boolean is_string();
    boolean is_f64();
    boolean is_i64();
    boolean is_u64();
    boolean is_object();
    boolean is_array();
    boolean is_empty_array();
    boolean is_string_array();
    boolean is_null();
    /// For any `DidMethodParameter` on which `DidMethodParameter::is_bool` returns `true`,
    /// the getter is guaranteed to return a `bool` value.
    boolean? get_bool_value();
    /// For any `DidMethodParameter` on which `DidMethodParameter::is_string` returns `true`,
    /// the getter is guaranteed to return a `string` value.
    string? get_string_value();
    /// For any `DidMethodParameter` on which `DidMethodParameter::is_string_array` returns `true`,
    /// the getter is guaranteed to return a ``string array.
    sequence<string>? get_string_array_value();
    /// For any `DidMethodParameter` on which `DidMethodParameter::is_f64` returns `true`,
    /// the getter is guaranteed to return a `f64` value.
    double? get_f64_value();
    /// For any `DidMethodParameter` on which `DidMethodParameter::is_i64` returns `true`,
    /// the getter is guaranteed to return a `i64` value.
    i64? get_i64_value();
    /// For any `DidMethodParameter` on which `DidMethodParameter::is_u64` returns `true`,
    /// the getter is guaranteed to return a `u64` value.
    u64? get_u64_value();
};

dictionary Jwk {
  string? alg;
  string? kid;
  string? kty;
  string? crv;
  string? x;
  string? y;
};

enum VerificationType {
    "Multikey",
    "JsonWebKey2020",
    "Ed25519VerificationKey2020",
};

dictionary VerificationMethod {
    string id;
    string controller;
    VerificationType verification_type;
    string? public_key_multibase;
    Jwk? public_key_jwk;
};

/// The error accompanying any `DidResolver` implementation.
/// It might occur while calling `DidResolver` methods.
[Error]
enum DidResolverError {
    /// Invalid method-specific identifier.
    "InvalidMethodSpecificId",
    /// Failed to serialize DID document (to JSON).
    "SerializationFailed",
    /// The supplied DID document is invalid or contains an argument which isn't part of the did specification/recommendation.
    "DeserializationFailed",
    /// Invalid DID parameter.
    "InvalidDidParameter",
    /// Invalid DID document.
    "InvalidDidDocument",
    /// Invalid DID log integration proof.
    "InvalidDataIntegrityProof"
};

interface DidDoc {
    /// The deserialization-based constructor.
    /// It attempts to deserialize an instance of type `DidDoc` from a string of JSON text.
    [Name=from_json, Throws=DidSidekicksError]
    constructor([ByRef] string json_content);
    /// Serializes this `DidDoc` object as a `String` of JSON.
    [Throws=DidSidekicksError]
    string to_json();
    sequence<string> get_context();
    string get_id();
    sequence<VerificationMethod> get_verification_method();
    sequence<VerificationMethod> get_authentication();
    sequence<VerificationMethod> get_capability_invocation();
    sequence<VerificationMethod> get_capability_delegation();
    sequence<VerificationMethod> get_assertion_method();
    sequence<string> get_controller();
    boolean get_deactivated();
    /// Returns a cryptographic public key (`Jwk`) referenced by the supplied `key_id`, if any.
    /// The key lookup is always done across all verification methods (`verificationMethod`) and
    /// verification relationships
    /// (`authentication`, `assertionMethod`, `keyAgreement`, `capabilityInvocation`, `capabilityInvocation`).
    ///
    /// If no such key exists, `DidSidekicksError::KeyNotFound` is returned.
    [Throws=DidSidekicksError]
    Jwk get_key(string key_id);
};

/// A simple container for both `DidDoc` and the related collection of `DidMethodParameter` objects.
interface DidDocExtended {
    DidDoc get_did_doc();
    record<string, DidMethodParameter> get_did_method_parameters();
};

/// W.r.t. any of specification versions available at https://identity.foundation/didwebvh
[Trait]
interface DidLogEntryJsonSchema {
    /// Delivers a proper JSON schema (in UTF-8 format) fully describing a DID log entry.
    string get_json_schema();
};

/// Represents any error condition that might occur in conjunction with `DidLogEntryValidator`
[Error]
enum DidLogEntryValidatorError {
    /// The supplied JSON `instance` is not a valid DID log.
    "ValidationError",
    /// The supplied JSON `instance` cannot be deserialized.
    "DeserializationError",
};

/// A compiled JSON Schema validator.
///
/// This structure represents a JSON Schema that has been parsed and compiled into
/// an efficient internal representation for validation. It contains the root node
/// of the schema tree and the configuration options used during compilation.
///
/// Intended to be used predominantly in conjunction with `DidLogEntryJsonSchema` trait implementations.
interface DidLogEntryValidator {
    /// Create a new DID log entry JSON Schema validator using `JSON Schema Draft 2020-12` specifications and supplied `schema`.
    [Name=from]
    constructor(DidLogEntryJsonSchema schema);
    /// Validate the supplied `instance` against the `schema` (supplied earlier via constructor).
    ///
    /// `DidLogEntryValidatorError` is returned as soon the very first validation error occurs.
    [Throws=DidLogEntryValidatorError]
    void validate(string instance);
};

/// The type represents a container for the byte serialization of an Ed25519
/// signature, and does not necessarily represent well-formed field or curve
/// elements.
///
/// Furthermore, the type supports (de)serialization w.r.t [Multibase Data Format].
///
/// [Multibase Data Format]: https://www.ietf.org/archive/id/draft-multiformats-multibase-08.html
interface Ed25519Signature {
    /// The type constructor from a multibase-encoded value.
    [Name=from_multibase, Throws=DidSidekicksError]
    constructor([ByRef] string multibase);
    /// The multibase-encoding method.
    string to_multibase();
};

/// The type represents Ed25519 secret key as defined in [RFC8032 § 5.1.5]:
///
/// > The private key is 32 octets (256 bits, corresponding to b) of
/// > cryptographically secure random data.
///
/// Furthermore, the type supports (de)serialization w.r.t [Multibase Data Format].
///
/// [RFC8032 § 5.1.5]: https://www.rfc-editor.org/rfc/rfc8032#section-5.1.5
/// [Multibase Data Format]: https://www.ietf.org/archive/id/draft-multiformats-multibase-08.html
interface Ed25519SigningKey {
    /// Generate an Ed25519 signing key as defined in [RFC8032 § 5.1.5].
    ///
    /// [RFC8032 § 5.1.5]: https://www.rfc-editor.org/rfc/rfc8032#section-5.1.5
    [Name=generate]
    constructor();
    /// The type constructor from a multibase-encoded value, as specified by [Multikey]:
    ///
    /// The encoding of an Ed25519 secret key MUST start with the two-byte prefix 0x8026 (the varint expression of 0x1300),
    /// followed by the 32-byte secret key data. The resulting 34-byte value MUST then be encoded using the base-58-btc alphabet,
    /// and then prepended with the base-58-btc Multibase header (z).
    ///
    /// [Multikey]: https://www.w3.org/TR/controller-document/#Multikey
    [Name=from_multibase, Throws=DidSidekicksError]
    constructor([ByRef] string multibase);
    /// Deserialize PKCS#8-encoded private key from PEM.
    [Name=from_pkcs8_pem, Throws=DidSidekicksError]
    constructor([ByRef] string pkcs8_pem);
    /// Load public key object from a PEM-encoded file on the local filesystem.
    [Name=read_pkcs8_pem_file, Throws=DidSidekicksError]
    constructor([ByRef] string pkcs8_pem_file);
    /// Write ASN.1 DER-encoded PKCS#8 private key to the given path.
    [Throws=DidSidekicksError]
    void write_pkcs8_pem_file([ByRef] string pkcs8_pem_file);
    /// The multibase-encoding method, as specified by [Multikey]:
    ///
    /// The encoding of an Ed25519 secret key MUST start with the two-byte prefix 0x8026 (the varint expression of 0x1300),
    /// followed by the 32-byte secret key data. The resulting 34-byte value MUST then be encoded using the base-58-btc alphabet,
    /// and then prepended with the base-58-btc Multibase header (z).
    ///
    /// [Multikey]: https://www.w3.org/TR/controller-document/#Multikey
    string to_multibase();
    /// Sign the given message and return a digital signature.
    Ed25519Signature sign([ByRef] string message);
    /// Get the `Ed25519VerifyingKey` for this `Ed25519SigningKey`.
    Ed25519VerifyingKey get_verifying_key();
};

/// The type represents an Ed25519 public key as defined in [RFC8032 § 5.1.5].
///
/// Furthermore, the type supports (de)serialization w.r.t [Multibase Data Format].
///
/// [RFC8032 § 5.1.5]: https://www.rfc-editor.org/rfc/rfc8032#section-5.1.5
/// [Multibase Data Format]: https://www.ietf.org/archive/id/draft-multiformats-multibase-08.html
interface Ed25519VerifyingKey {
    /// The type constructor from a multibase-encoded value, as specified by [Multikey]:
    ///
    /// The encoding of an Ed25519 public key MUST start with the two-byte prefix 0xed01 (the varint expression of 0xed),
    /// followed by the 32-byte public key data.
    /// The resulting 34-byte value MUST then be encoded using the base-58-btc alphabet,
    /// and then prepended with the base-58-btc Multibase header (z).
    ///
    /// [Multikey]: https://www.w3.org/TR/controller-document/#Multikey
    [Name=from_multibase, Throws=DidSidekicksError]
    constructor([ByRef] string multibase);
    /// Deserialize PKCS#8-encoded public key from PEM.
    [Name=from_public_key_pem, Throws=DidSidekicksError]
    constructor([ByRef] string public_key_pem);
    /// Load public key object from a PEM-encoded file on the local filesystem.
    [Name=read_public_key_pem_file, Throws=DidSidekicksError]
    constructor([ByRef] string public_key_pem_file);
    /// Write ASN.1 DER-encoded public key to the given path.
    [Throws=DidSidekicksError]
    void write_public_key_pem_file([ByRef] string public_key_pem_file);
    /// The multibase-encoding method, as specified by [Multikey]:
    ///
    /// The encoding of an Ed25519 public key MUST start with the two-byte prefix 0xed01 (the varint expression of 0xed),
    /// followed by the 32-byte public key data.
    /// The resulting 34-byte value MUST then be encoded using the base-58-btc alphabet,
    /// and then prepended with the base-58-btc Multibase header (z).
    ///
    /// [Multikey]: https://www.w3.org/TR/controller-document/#Multikey
    string to_multibase();
    /// Strictly verify a signature on a message with this public key.
    [Throws=DidSidekicksError]
    void verify_strict([ByRef] string message, [ByRef] Ed25519Signature signature);
    /// Strictly verify a signature on a hex message with this public key.
    [Throws=DidSidekicksError]
    void verify_strict_from_hex([ByRef] string message_hex, [ByRef] Ed25519Signature signature);
};

interface DataIntegrityProof {
    [Name=from_json_string, Throws=DidSidekicksError]
    constructor(string json);
};

interface CryptoSuiteProofOptions {
    [Name=default]
    constructor();
    [Name=new_eddsa_jcs_2022, Throws=DidSidekicksError]
    constructor(string? created_dt_rfc3339, string verification_method, string? proof_purpose, sequence<string>? context, string? challenge);
};

interface JcsSha256Hasher {
    [Name=default]
    constructor();
    [Throws=DidSidekicksError]
    string encode_hex([ByRef] string json);
    [Throws=DidSidekicksError]
    string base58btc_encode_multihash([ByRef] string json);
};

interface EddsaJcs2022Cryptosuite {
    [Name=from_signing_key]
    constructor([ByRef] Ed25519SigningKey signing_key);
    [Name=from_verifying_key]
    constructor([ByRef] Ed25519VerifyingKey verifying_key);
    [Throws=DidSidekicksError]
    string add_proof([ByRef] string unsecured_document, [ByRef] CryptoSuiteProofOptions options);
    [Throws=DidSidekicksError]
    void verify_proof([ByRef] DataIntegrityProof proof, [ByRef] string doc_hash);
};
